<script>
/* /scripts/db.js â€” PouchDB (sync) -> Dexie -> localStorage + bridges for pharmacy/lab */
(function () {
  const DB = (window.DB = window.DB || {});
  const TODAY = () => new Date().toISOString().slice(0, 10);
  DB.todayISO = TODAY;

  const cfg = (window.APP_CONFIG || {});
  const couchUrlRaw = ((cfg && cfg.couchUrl) || '').trim();

  /* ---------- Safe URL helpers ---------- */
  function ensureSlash(u){ return u && !u.endsWith('/') ? (u + '/') : u; }
  function couchBase(){ return ensureSlash(couchUrlRaw || ''); }

  /* ---------- Lazy-load PouchDB if missing ---------- */
  function ensurePouch() {
    return new Promise((res) => {
      if (window.PouchDB) return res(true);
      const s = document.createElement('script');
      s.src = 'https://cdn.jsdelivr.net/npm/pouchdb@8.0.1/dist/pouchdb.min.js';
      s.onload = () => res(true);
      s.onerror = () => res(false);
      document.head.appendChild(s);
    });
  }

  /* ---------- LocalStorage Shim (stable keys kept for compatibility) ---------- */
  const LS_KEY = {
    patients:  'clinic_ls_patients',
    bookings:  'clinic_ls_bookings',
    opd:       'clinic_ls_opd',
    seq:       'clinic_ls_seq',

    // Pharmacy
    pharma_stock:     'pharma_stock_json',
    pharma_sales:     'pharma_sales_json',
    pharma_purchases: 'pharma_purchases_json',
    pharma_returns:   'pharma_returns_json',

    // Lab
    lab_tests:   'lab_tests_json',
    lab_orders:  'lab_orders_json',
    lab_records: 'lab_records_json',
    lab_reports: 'lab_reports_json',
  };
  const BRIDGE_TS_KEY = (k) => k + '_ts';

  function lsGet(k, d){ try { return JSON.parse(localStorage.getItem(k) || 'null') ?? d; } catch { return d; } }
  function lsSet(k, v){ try { localStorage.setItem(k, JSON.stringify(v)); } catch {} }
  function lsSetTs(k){ try { localStorage.setItem(BRIDGE_TS_KEY(k), String(Date.now())); } catch {} }

  function makeShim() {
    const shim = {
      kind: 'ls',
      async ensure(){ return true; },

      // Patients/Bookings/OPD (unchanged)
      async findPatientByPID(pid){ return (lsGet(LS_KEY.patients,[]).find(p=>p.pid===pid)) || null; },
      async findPatientByNamePhone(n,p){
        const r = lsGet(LS_KEY.patients,[]).find(x=>x.patientName===n && x.contact===p);
        return r ? r.pid : null;
      },
      async nextPID(){
        const seq=lsGet(LS_KEY.seq,{pid:0,token_by_date:{}}); seq.pid=(seq.pid||0)+1; lsSet(LS_KEY.seq,seq);
        return 'P'+String(seq.pid).padStart(5,'0');
      },
      async addOrUpdatePatient(p){
        let a = lsGet(LS_KEY.patients,[]);
        if(!p.pid) p.pid = await shim.nextPID();
        const i = a.findIndex(x=>x.pid===p.pid);
        if(i>=0) a[i]=p; else a.push(p);
        lsSet(LS_KEY.patients,a);
        return p.pid;
      },
      async nextToken(){
        const today=TODAY();
        const seq=lsGet(LS_KEY.seq,{pid:0,token_by_date:{}});
        const tbd = seq.token_by_date || {};
        tbd[today] = (tbd[today]||0)+1; seq.token_by_date=tbd; lsSet(LS_KEY.seq,seq);
        return tbd[today];
      },
      async addBooking(b){
        const a=lsGet(LS_KEY.bookings,[]); b.id=(a[a.length-1]?.id||0)+1; a.push(b); lsSet(LS_KEY.bookings,a);
        try { localStorage.setItem('bookings_changed', String(Date.now())); } catch {}
        return b.id;
      },
      async listBookingsToday(){
        const t=TODAY(); return lsGet(LS_KEY.bookings,[]).filter(r=>r.date===t).sort((a,b)=>a.ts-b.ts);
      },
      async getLatestBookingTodayByPID(pid){
        const t=TODAY(); const arr=lsGet(LS_KEY.bookings,[]).filter(r=>r.date===t && r.pid===pid).sort((a,b)=>b.ts-a.ts);
        return arr[0] || null;
      },
      async setBookingStatus({pid, token, status}){
        const t=TODAY(); const a=lsGet(LS_KEY.bookings,[]);
        let row=a.find(r=>r.date===t && r.pid===pid && r.token===token)
              || a.filter(r=>r.date===t && r.pid===pid).sort((a,b)=>b.ts-a.ts)[0];
        if(!row) return false; row.status=status; lsSet(LS_KEY.bookings,a);
        try { localStorage.setItem('bookings_status_changed', String(Date.now())); } catch {}
        return true;
      },
      async addOPD(rec){ const a=lsGet(LS_KEY.opd,[]); rec.id=(a[a.length-1]?.id||0)+1; a.push(rec); lsSet(LS_KEY.opd,a); return rec.id; },
      async countOPDByDate(d){ return lsGet(LS_KEY.opd,[]).filter(r=>r.date===d).length; },
      async listOPDByDate(d){ return lsGet(LS_KEY.opd,[]).filter(r=>r.date===d).sort((a,b)=>b.ts-a.ts); },
    };
    return shim;
  }

  /* ---------- Dexie fallback (when Pouch not usable) ---------- */
  async function dexieBackend() {
    if (!window.Dexie || !('indexedDB' in window)) throw new Error('Dexie missing');
    const db = new Dexie('clinicdb');
    db.version(1).stores({
      patients:'pid,patientName,contact,dob',
      bookings:'++id,date,ts,pid,token,status',
      opd:'++id,ts,pid,date'
    });
    await db.open();
    return {
      kind: 'idb', __db: db, async ensure(){return true;},
      async findPatientByPID(pid){ return db.table('patients').get(pid)||null; },
      async findPatientByNamePhone(n,p){ return (await db.table('patients').where({patientName:n,contact:p}).first())?.pid||null; },
      async nextPID(){ const last=(await db.table('patients').orderBy('pid').reverse().first())?.pid||'P00000'; const num=parseInt(String(last).replace(/\D/g,''),10)||0; return 'P'+String(num+1).padStart(5,'0'); },
      async addOrUpdatePatient(p){ if(!p.pid)p.pid=await this.nextPID(); await db.table('patients').put(p); return p.pid; },
      async nextToken(){ const t=TODAY(); const rows=await db.table('bookings').where('date').equals(t).toArray(); const max=rows.reduce((m,r)=>Math.max(m,+r.token||0),0); return max+1; },
      async addBooking(b){ return db.table('bookings').add(b); },
      async listBookingsToday(){ const t=TODAY(); const rows=await db.table('bookings').where('date').equals(t).toArray(); rows.sort((a,b)=>a.ts-b.ts); return rows; },
      async getLatestBookingTodayByPID(pid){ const t=TODAY(); let rows=await db.table('bookings').where('date').equals(t).and(r=>r.pid===pid).toArray(); rows.sort((a,b)=>b.ts-a.ts); return rows[0]||null; },
      async setBookingStatus({pid, token, status}){ const t=TODAY(); let row=await db.table('bookings').where('date').equals(t).and(r=>r.pid===pid && r.token===token).first(); if(!row){ const rows=await db.table('bookings').where('date').equals(t).and(r=>r.pid===pid).toArray(); rows.sort((a,b)=>b.ts-a.ts); row=rows[0]||null; } if(!row) return false; await db.table('bookings').update(row.id,{status}); try{localStorage.setItem('bookings_status_changed',String(Date.now()))}catch{}; return true; },
      async addOPD(rec){ return db.table('opd').add(rec); },
      async countOPDByDate(d){ return db.table('opd').where('date').equals(d).count(); },
      async listOPDByDate(d){ const list=await db.table('opd').where('date').equals(d).toArray(); list.sort((a,b)=>b.ts-a.ts); return list; }
    };
  }

  /* ---------- PouchDB primary backend with sync ---------- */

  // Local and Remote DB names
  const DBN = {
    patients:  'clinic-patients',
    bookings:  'clinic-bookings',
    opd:       'clinic-opd',

    // Pharmacy
    pharma_stock:     'clinic-pharma-stock',
    pharma_sales:     'clinic-pharma-sales',
    pharma_purchases: 'clinic-pharma-purchases',
    pharma_returns:   'clinic-pharma-returns',

    // Lab
    lab_tests:   'clinic-lab-tests',
    lab_orders:  'clinic-lab-orders',
    lab_records: 'clinic-lab-records',
    lab_reports: 'clinic-lab-reports',
  };

  // Bridges: localStorage key <-> DB name
  const BRIDGE = [
    [LS_KEY.pharma_stock,     DBN.pharma_stock],
    [LS_KEY.pharma_sales,     DBN.pharma_sales],
    [LS_KEY.pharma_purchases, DBN.pharma_purchases],
    [LS_KEY.pharma_returns,   DBN.pharma_returns],
    [LS_KEY.lab_tests,        DBN.lab_tests],
    [LS_KEY.lab_orders,       DBN.lab_orders],
    [LS_KEY.lab_records,      DBN.lab_records],
    [LS_KEY.lab_reports,      DBN.lab_reports],
  ];

  let back = null;     // chosen backend

  async function chooseBackend(){
    if (back) return back;

    const pouchReady = await ensurePouch();
    if (pouchReady && window.PouchDB) {
      try {
        // Open local DBs
        const L = {};
        Object.keys(DBN).forEach(k => { L[k] = new PouchDB(DBN[k]); });

        // Wire live sync (if remote set)
        const remoteBase = couchBase();
        const R = {};
        if (remoteBase) {
          Object.keys(DBN).forEach(k => {
            const url = remoteBase + encodeURIComponent(DBN[k]);
            R[k] = new PouchDB(url, { skip_setup: false });
            // Live two-way sync with retry
            L[k].sync(R[k], { live:true, retry:true })
                .on('error', (e)=>console.warn('[sync error]', DBN[k], e && e.message || e));
          });
        }

        // Start localStorage bridges (compat with existing pages)
        await runBridgesOnce(L);

        // Also listen for future localStorage changes to mirror into Pouch
        window.addEventListener('storage', (ev)=>{
          // only act for known keys
          const pair = BRIDGE.find(([k]) => k === ev.key);
          if(!pair) return;
          // debounce a bit
          setTimeout(()=>bridgeLocalToPouch(L, pair[0], pair[1]).catch(()=>{}), 150);
        });

        back = {
          kind: remoteBase ? 'pouch-sync' : 'pouch-local',
          __local: L, __remote: R,
          async ensure(){ return true; },

          /* ---- Patients / Bookings / OPD (document-centric, simple queries) ---- */
          async findPatientByPID(pid){
            try { const doc = await L.patients.get(pid); return doc||null; } catch { return null; }
          },
          async findPatientByNamePhone(n,p){
            const q = await L.patients.allDocs({include_docs:true});
            const hit = q.rows.map(r=>r.doc).find(d=>d.patientName===n && d.contact===p);
            return hit ? hit._id : null;
          },
          async nextPID(){
            const q = await L.patients.allDocs();
            const max = q.rows.map(r=>r.id)
                              .filter(id=>/^P\d+$/.test(id))
                              .reduce((m,id)=>Math.max(m,parseInt(id.slice(1),10)||0),0);
            return 'P' + String(max+1).padStart(5,'0');
          },
          async addOrUpdatePatient(p){
            if(!p.pid) p.pid = await this.nextPID();
            try {
              const old = await L.patients.get(p.pid).catch(()=>null);
              const doc = old ? {...old, ...p} : {...p, _id: p.pid};
              await L.patients.put(doc);
            } catch(e){ console.warn('[patients put]', e && e.message || e); }
            return p.pid;
          },
          async nextToken(){
            const t=TODAY();
            const q = await L.bookings.allDocs({include_docs:true});
            const rows = q.rows.map(x=>x.doc).filter(r=>r.date===t);
            const max = rows.reduce((m,r)=>Math.max(m,+r.token||0),0);
            return max+1;
          },
          async addBooking(b){
            const _id = b._id || ('bk-' + Date.now() + '-' + (Math.random()*1e6|0));
            await L.bookings.put({...b, _id});
            try { localStorage.setItem('bookings_changed', String(Date.now())); } catch {}
            return _id;
          },
          async listBookingsToday(){
            const t=TODAY(); const q=await L.bookings.allDocs({include_docs:true});
            return q.rows.map(x=>x.doc).filter(r=>r.date===t).sort((a,b)=>a.ts-b.ts);
          },
          async getLatestBookingTodayByPID(pid){
            const t=TODAY(); const q=await L.bookings.allDocs({include_docs:true});
            const rows = q.rows.map(x=>x.doc).filter(r=>r.date===t && r.pid===pid).sort((a,b)=>b.ts-a.ts);
            return rows[0] || null;
          },
          async setBookingStatus({pid, token, status}){
            const t=TODAY(); const q=await L.bookings.allDocs({include_docs:true});
            const rows = q.rows.map(x=>x.doc).filter(r=>r.date===t && r.pid===pid);
            const row = rows.find(r=>r.token===token) || rows.sort((a,b)=>b.ts-a.ts)[0];
            if(!row) return false;
            await L.bookings.put({...row, status});
            try{ localStorage.setItem('bookings_status_changed', String(Date.now())); }catch{}
            return true;
          },
          async addOPD(rec){
            const _id = rec._id || ('opd-' + Date.now() + '-' + (Math.random()*1e6|0));
            await L.opd.put({...rec, _id}); return _id;
          },
          async countOPDByDate(d){
            const q=await L.opd.allDocs({include_docs:true});
            return q.rows.map(x=>x.doc).filter(r=>r.date===d).length;
          },
          async listOPDByDate(d){
            const q=await L.opd.allDocs({include_docs:true});
            return q.rows.map(x=>x.doc).filter(r=>r.date===d).sort((a,b)=>b.ts-a.ts);
          },

          /* ---- Optional: expose Pouch handles for advanced pages ---- */
          _pouch(name){ return L[name]; }
        };

        return back;
      } catch (e) {
        console.warn('[DB] Pouch init failed:', e && e.message || e);
      }
    }

    // Fallbacks
    try {
      back = await dexieBackend();
      return back;
    } catch (e) {
      console.warn('[DB] Dexie failed; using localStorage shim. Reason:', e && e.message || e);
      back = makeShim();
      return back;
    }
  }

  /* ---------- localStorage <-> Pouch bridge (compat for existing pages) ---------- */

  async function runBridgesOnce(L) {
    // One pass: push LS arrays into Pouch, then pull all Pouch into LS
    for (const [lsKey, dbName] of BRIDGE) {
      await bridgeLocalToPouch(L, lsKey, dbName).catch(()=>{});
      await bridgePouchToLocal(L, lsKey, dbName).catch(()=>{});
    }
  }

  function normalizeDocsFromArray(arr){
    // turn array items into docs with stable _id when possible
    return (Array.isArray(arr)?arr:[]).map((x,i)=>{
      const baseId = x._id
        || x.id
        || x.pid
        || (x.batch && x.name ? `${x.name}|${x.batch}` : null)
        || ('ls-' + (x.ts || Date.now()) + '-' + i);
      return { _id: String(baseId), ...x, ts: x.ts || new Date().toISOString() };
    });
  }

  async function bridgeLocalToPouch(L, lsKey, dbName){
    const db = L[Object.keys(DBN).find(k=>DBN[k]===dbName)];
    if(!db) return;
    const arr = lsGet(lsKey, []);
    const docs = normalizeDocsFromArray(arr);
    if(!docs.length) return;
    // bulk upsert: fetch existing, then put
    const existing = await db.allDocs({ include_docs:true });
    const existingIds = new Set(existing.rows.map(r=>r.id));
    const toPut = docs.map(d => {
      const ex = existing.rows.find(r=>r.id===d._id);
      return ex && ex.doc ? {...ex.doc, ...d} : d;
    });
    try { await db.bulkDocs(toPut); lsSetTs(lsKey); }
    catch(e){ console.warn('[bridgeLocalToPouch]', lsKey, e && e.message || e); }
  }

  async function bridgePouchToLocal(L, lsKey, dbName){
    const db = L[Object.keys(DBN).find(k=>DBN[k]===dbName)];
    if(!db) return;
    const all = await db.allDocs({ include_docs:true });
    const arr = all.rows
      .filter(r=>r.doc && !/^_design\//.test(r.id))
      .map(r=>{ const {_id,_rev, ...rest} = r.doc; return {...rest, _id}; });
    lsSet(lsKey, arr);
    lsSetTs(lsKey);
  }

  /* ---------- Public API ---------- */
  DB.health = async () => ({ backend: (await chooseBackend()).kind });

  // Core
  DB.findPatientByPID = async (pid) => (await chooseBackend()).findPatientByPID(pid);
  DB.findPatientByNamePhone = async (n,p) => (await chooseBackend()).findPatientByNamePhone(n,p);
  DB.addOrUpdatePatient = async (p) => (await chooseBackend()).addOrUpdatePatient(p);
  DB.nextPID = async () => (await chooseBackend()).nextPID();
  DB.nextToken = async () => (await chooseBackend()).nextToken();
  DB.addBooking = async (b) => (await chooseBackend()).addBooking(b);
  DB.listBookingsToday = async () => (await chooseBackend()).listBookingsToday();
  DB.getLatestBookingTodayByPID = async (pid) => (await chooseBackend()).getLatestBookingTodayByPID(pid);
  DB.setBookingStatus = async (args) => (await chooseBackend()).setBookingStatus(args);
  DB.addOPD = async (rec) => (await chooseBackend()).addOPD(rec);
  DB.countOPDByDate = async (d) => (await chooseBackend()).countOPDByDate(d);
  DB.listOPDByDate = async (d) => (await chooseBackend()).listOPDByDate(d);

  // Optional: expose a handle for advanced pages (pharmacy/lab) to use direct Pouch APIs
  DB.pouch = async (name /* one of keys from DBN: 'pharma_stock', 'lab_tests', etc. */) => {
    const b = await chooseBackend();
    if (b.kind.startsWith('pouch') && b._pouch) {
      return b._pouch(name);
    }
    return null; // not available in Dexie/LS
  };

  DB.enableDiagnostics = (flag) => { try { localStorage.setItem('_diag_enabled', flag ? '1' : '0'); } catch {} };

})();
</script>

<!-- Live Dexie watcher (kept for backwards compatibility with pages that rely on it) -->
<script>
if (typeof window !== 'undefined' && window.Dexie) {
  const dbNotify = new Dexie('clinicdb');
  dbNotify.version(1).stores({ bookings: '++id,date,token,patientName' });
  let lastCount = 0;
  async function watchBookings() {
    const today = new Date().toISOString().slice(0,10);
    const count = await dbNotify.table('bookings').where('date').equals(today).count();
    if (count > lastCount) {
      const latest = await dbNotify.table('bookings').where('date').equals(today).reverse().limit(1).first();
      const event = new CustomEvent('newBooking', { detail: latest });
      window.dispatchEvent(event);
      lastCount = count;
    } else { lastCount = count; }
  }
  setInterval(watchBookings, 4000);
}
</script>